
<h1 class="sectionedit1" id="nodejs_그리고_javascript">Node.JS 그리고 JavaScript</h1>
<div class="level1">

</div>
<!-- EDIT1 SECTION "Node.JS 그리고 JavaScript" [1-45] -->
<h2 class="sectionedit2" id="jsonp란_무엇인가">JSONP란 무엇인가?</h2>
<div class="level2">
<pre class="code">&quot;JSON with Padding&quot;</pre>

<p>
자바스크립트에서 서로 다른 도메인 간의 데이터 요청을 위한 통신 기법. 평소 이것은 same-origin-policy에 의하여 웹브라우저 차원에서 금지하고 있다. JSONP는 브라우저가 &lt;script&gt; 에서 same-origin policy를 강요하지 않는 것을 이용한 것이다. &lt;script&gt; 태그를 활용하는 것이므로, 이것은 GET요청에 대해서만 유효하다.
</p>

</div>
<!-- EDIT2 SECTION "JSONP란 무엇인가?" [46-511] -->
<h2 class="sectionedit3" id="callback의_지옥">Callback의 지옥</h2>
<div class="level2">
<pre class="code">Callback Hell</pre>

<p>
이것은 간단히 아래의 코드형태로 인한 문제를 말하는 것임.
</p>
<pre class="code">$.ajax({
  url:&quot;&quot;,
  data:&quot;&quot;,
})
.done({
  $.ajax({
    url:&quot;&quot;,
    data:&quot;&quot;,
  })
  .done({
    $.ajax({
      ...
    })
});</pre>

<p>
위와 같은 형태의 코드는 로직의 동작 흐름을 직관적으로 볼 수 없게 하는데, 이것은 아래와 같은 여러가지 문제를 유발한다.
</p>
<ul>
<li class="level1"><div class="li"> 코드 가독성 저하</div>
</li>
<li class="level2"><div class="li"> 디버깅 난이도 상승</div>
</li>
<li class="level2"><div class="li"> 예외 처리의 어려움</div>
</li>
</ul>

<p>
위의 문제를 해결 하기 위해서는…
</p>
<ul>
<li class="level1"><div class="li"> 모듈화 - 익명 함수의 사용을 지양하고 함수를 따로 선언하여 활용하자.</div>
</li>
<li class="level1"><div class="li"> Promise Pattern의 활용 - 더 찾아볼것.</div>
</li>
<li class="level1"><div class="li"> 코드를 얕게 하기. - 하나의 함수가 수행하는 역할을 최소화 할 것.</div>
</li>
</ul>

<p>
WaterfallJS 등은 비동기적인 함수의 호출을 동기적으로 수행할 수 있게 한다.
</p>

</div>
<!-- EDIT3 SECTION "Callback의 지옥" [512-] -->